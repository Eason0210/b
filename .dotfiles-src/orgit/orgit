#!/usr/bin/env ruby

require 'open3'
require 'thread'
require 'fileutils'

require 'bundler/setup'

require 'json'
require 'github_api'
require_relative './github'

class Orgit # :nodoc:
  LocalRepo  = Struct.new(:name, :fetched_at, :ref)

  Repo = Struct.new(:name, :pushed_at, :fetched_at, :default_branch, :ref, :remote_sha) do
    def needs_clone?;   pushed_at && !fetched_at end
    def needs_delete?; !pushed_at &&  fetched_at end
    def on_default_branch?; default_branch == ref end

    def needs_fetch?(path)
      path = File.expand_path(name, path)
      # clone, not fetch
      return false unless Dir.exist?(path)

      # empty project
      return false if remote_sha.nil?

      begin
        o = File.read(File.expand_path(".git/refs/remotes/origin/#{default_branch}", path))
      rescue Errno::ENOENT
        o = File
          .read(File.expand_path(".git/packed-refs", path))
          .scan(%r{^([^\s]+)\s+refs/remotes/origin/#{Regexp.quote(default_branch)}$}m).flatten.first
      end

      if o.nil?
        puts "\x1b[1;31mcouldn't determine status for repo: \x1b[0m#{File.basename(path)}"
        return true
      end

      o.chomp != remote_sha
    end
  end

  class ParallelFetcher
    def initialize(path, threads = 10)
      @path = path
      @threads = threads
      @q = Queue.new
    end

    def run(repos)
      thrs = []
      @threads.times do
        thrs << Thread.new do
          while repo = @q.pop
            path = File.expand_path(repo.name, @path)
            if Dir.exist?(path)
              _, t = Open3.capture2e('git', '-C', path, 'fetch', 'origin', repo.default_branch)
            else
              _, t = Open3.capture2e('git', 'clone', "git@github.com:shopify/#{repo.name}", path)
            end
            if t.success?
              puts "\x1b[1;32m✓\x1b[0m #{repo.name} fetched"
            else
              puts "\x1b[1;31m✗\x1b[0m #{repo.name} fetch failed"
            end
          end
        end
      end

      repos.each { |r| @q << r }
      @q.close
      thrs.map(&:join)
    end
  end

  def initialize(path)
    @path = File.expand_path(path)
  end

  def local_repos
    @local_repos ||= gen_local_repo_list
  end
  
  def remote_repos
    @remote_repos ||= gen_remote_repo_list
  end

  def repos
    @repos ||= gen_repo_list
  end

  def missing_repos
    repos.select(&:needs_clone?)
  end

  def extra_repos
    repos.select(&:needs_delete?)
  end

  def repos_needing_update
    repos.select { |r| r.needs_fetch?(@path) }
  end

  def delete_repo(repo)
    p = repo_path(repo)
    print "deleting #{p}..."
    STDOUT.flush
    FileUtils.rm_rf(repo_path(repo))
    puts ' done!'
  end

  def parallel_fetch(repos)
    ParallelFetcher.new(@path, 10).run(repos)
  end

  def checkout_latest(repo)
    unless repo.on_default_branch?
      puts "\x1b[1;31mrepo is on non-default branch and cannot be updated:\x1b[0m #{repo.name} (#{repo.ref} != #{repo.default_branch})"
      return
    end

    path = File.expand_path(repo.name, @path)

    begin
      fetch_head = File.read("#{path}/.git/FETCH_HEAD").split(/\s+/).first
      return if fetch_head.nil? # there are no commits
    rescue Errno::ENOENT
      return
    end

    head, t = Open3.capture2e('git', '-C', path, 'rev-parse', 'HEAD')
    head = t.success? ? head.chomp : ''

    return if head == fetch_head

    unless head.empty?
      o, t = Open3.capture2e('git', '-C', path, 'status', '--porcelain')
      if !t.success? || !o.chomp.empty?
        puts "\x1b[1;31mcannot fast-forward repo with dirty working tree:\x1b[0m #{repo.name}"
        return
      end
      _, t = Open3.capture2e('git', '-C', path, 'merge-base', '--is-ancestor', head, fetch_head)
      unless t.success?
        puts "\x1b[1;31mcannot fast-forward repo with unpushed commits\x1b[0m #{repo.name}"
        return
      end
    end

    reset_repo(path, repo.remote_sha)
  end

  def repo_dirty?(repo)
    path = File.expand_path(repo.name, @path)
    # o, t = Open3.capture2e('git', '-C', path, 'status', '--porcelain')
    o, t = Open3.capture2e('git', '-C', path, 'diff-index', '--quiet', 'HEAD', '--')
    !t.success? && o !~ /bad revision/
  end

  private

  def reset_repo(path, sha)
    _, t = Open3.capture2e('git', '-C', path, 'reset', '--hard', sha)
    raise "??? #{o} / #{args.inspect}" unless t.success?
  end

  def repo_path(repo)
    File.expand_path(repo.name, @path)
  end

  def gen_repo_list
    repos = {}
    local_repos.each do |lr|
      repos[lr.name] = Repo.new(lr.name, nil, lr.fetched_at, nil, lr.ref, nil)
    end
    remote_repos.each do |rr|
      repos[rr.name] ||= Repo.new(rr.name, nil, nil, nil, nil)
      repos[rr.name].pushed_at = rr.pushed_at
      repos[rr.name].default_branch = rr.default_branch
      repos[rr.name].remote_sha = rr.sha
    end
    repos.map { |_, v| v }
  end

  def gen_local_repo_list
    (Dir.entries(@path) - %w(. ..)).map do |name|
      path = File.expand_path(name, @path)
      next unless Dir.exist?(path) # skip .DS_Store and the like
      fetched_at = begin
        File.stat("#{path}/.git/FETCH_HEAD").mtime
      rescue Errno::ENOENT
        Time.at(0)
      end
      ref = begin
        head = File.read("#{path}/.git/HEAD").chomp
        head.scan(%r{ref: refs/heads/(.*)}).flatten.first || head
      rescue Errno::ENOENT
        nil
      end
      LocalRepo.new(name, fetched_at, ref)
    end.compact
  end

  def gen_remote_repo_list
    github.repos
  end

  def github
    @github ||= Orgit::Github.new(oauth_token)
  end

  def oauth_token
    token, err, t = Open3.capture3(
      'security',
      'find-generic-password',
      '-w', # print only the password
      '-l', 'github-oauth-repo' 
    )
    raise "security find-generic-password failed: #{err}" unless t.success?
    token
  end
end

module CLI
  def self.run(*argv)
    case argv.shift
    when 'sync'
      CLI.sync(*argv)
    when 'dirty'
      CLI.dirty(*argv)
    else
      puts "usage: #$0 sync"
      exit 1
    end
  end

  def self.dirty(*argv)
    orgit = Orgit.new('~/src/github.com/shopify')
    q = Queue.new
    thrs = []
    10.times do
      thrs << Thread.new do
        while lr = q.pop
          puts(lr.name + "\n") if orgit.repo_dirty?(lr)
        end
      end
    end
    orgit.local_repos.each { |lr| q << lr }
    q.close
    thrs.map(&:join)
  end

  def self.sync(*argv)
    orgit = Orgit.new('~/src/github.com/shopify')

    if orgit.extra_repos.any?
      puts "found #{orgit.extra_repos.size} that don't exist on the remote."
    end
    orgit.extra_repos.each do |repo|
      puts "delete extra repo? (#{repo.name})"
      orgit.delete_repo(repo) if STDIN.gets =~ /y/i
    end

    CLI.info "determining which repos need updating..."
    to_fetch = (orgit.missing_repos + orgit.repos_needing_update)
    if to_fetch.size.zero?
      CLI.info "no new commits to fetch."
    else
      CLI.info "fetching #{to_fetch.size} repos..."
    end
    orgit.parallel_fetch(to_fetch)

    CLI.info "checking out latest code everywhere..."
    orgit.repos.each do |repo|
      next if repo.needs_delete?
      orgit.checkout_latest(repo)
    end
  end

  def self.info(msg)
    puts "\x1b[1;3;34m%\x1b[0;3m #{msg}\x1b[0m"
  end
end

CLI.run(*ARGV)
