#!/bin/bash
#
# Depends on https://github.com/burke/matcher
#
# Terse syntax for connecting to machines in Shopify datacenters.
#
# Syntax:
#
#   , [connection type] [dc selector] <space> <hostname search term> [args]
#
#   connection type can be:
#     * (blank): SSH to the host.
#     * u: scp upload
#     * ur: recursive scp upload
#     * d: scp download
#     * dr: recursive scp download
#
#   dc selector can be:
#     * (blank): any DC
#     * c: chicago
#     * a: ashburn
#
#   The DC selector will be combined with the hostname search term and used as
#   input to a fuzzy-find on all hostnames as returned by knife.
#
#   Hostnames are stored in the form `chi/jobs21`, `ash/borg0`, etc., and these
#   are the strings matched against. `,c j21` fuzzy-finds for "chi/j21", which
#   returns `chi/jobs21`, which is translated to `jobs21.chi.shopify.com`
#   before connecting.
#
# Examples:
#
#   , s2p   :: connect to sb2-perf.chi.shopify.com
#   ,c j21  :: connect to jobs21.chi.shopify.com
#   ,a br0  :: connect to borg0.ash.shopify.com
#   ,dc sb1 /etc/lsb-release :: download the file to the current directory
#   ,ua bg0 ./borg-run :: upload borg-run to your home directory on `borg0.ash`.
#   ,urc bg2 borg-baseimage '/usr/src' :: upload the borg-baseimage directory to `/usr/src` on `borg2.chi`.
#
# Installation
#
#   Save to `~/bin`
#   cd to `~/bin`
#   ln , ,u ; ln , ,c ; ln , ,d ; ln , ,dc ; ln , ,da ; ln , ,u ; ln , ,ua ; ln , ,uc ; ln , ,ur ; ln , ,ura ; ln , ,urc ; ln , ,dr ; ln , ,drc ; ln , ,dra; ln , ,g
#   Run `,g`

set -eo pipefail

gen_machines() {
  ruby -ne 'puts $_.chomp.sub(/\.shopify\.com$/,"").split(?.).reverse*?/' \
    <(knife node list) \
    > ~/.machines
}

do_ssh() {
  machine=$(resolve_machine "$1");shift
  ssh "${machine}" "$@"
}

scp_dn() {
  machine=$(resolve_machine "$1");shift
  echo "action:  scp-down"

  remote=$1;shift
  _local="$@"
  if [[ -z "${_local}" ]]; then
    _local="."
  fi
  echo "remote:  ${remote}"
  echo "local:   ${_local}"

  scp ${scp_opts} "${machine}:${remote}" "${_local}"
}


scp_up() {
  machine=$(resolve_machine "$1");shift
  echo "action:  scp-up"

  if [[ "$#" == "1" ]]; then
    _local=$1
    remote=""
  else
    arr=( "$@" )
    remote="${arr[${#arr[@]}-1]}"
    unset arr[${#arr[@]}-1]
    _local="${arr[@]}"
  fi
  echo "local:   ${_local}"
  echo "remote:  ${remote}"

  scp ${scp_opts} "${_local}" "${machine}:${remote}"
}

scp_dnr() {
  scp_opts="-r"
}

scp_upr() {
  scp_opts="-r"
}

knife_e() {
  machine=$(resolve_machine "$1");shift
  echo "action:  knife-edit"
  knife node edit "${machine}"
}

create_links() {
  commands=("d" "g" "dr" "u" "ur" "k")
  locations=("c" "a")
  dir=$(dirname $0)
  (
    set +e
    for loc in ${locations[@]}; do
      ln -s "${dir}/," "${dir}/,${loc}"
    done

    for cmd in ${commands[@]}; do
      ln -s "${dir}/," "${dir}/,${cmd}"
      for loc in ${locations[@]}; do
        ln -s "${dir}/," "${dir}/,${cmd}${loc}"
      done
    done
  ) 2>/dev/null || true
}

main() {
  create_links

  path="$(basename $0)"  # e.g.:  ,drc
  cmd="${path: 1}"       # e.g.:  drc
  last_char="${cmd: -1}" # e.g.:  c

  search_base=""
  case "${last_char}" in
  "c")
    search_base="chi/"
    cmd="${cmd%?}"       # e.g.: dr
    ;;
  "a")
    search_base="ash/"
    cmd="${cmd%?}"       # e.g.: dr
    ;;
  esac

  case "${cmd}" in
  "g") cmd_func="gen_machines" ;;
  "")  cmd_func="do_ssh"       ;;
  "d") cmd_func="scp_dn"       ;;
  "u") cmd_func="scp_up"       ;;
  "ur")cmd_func="scp_upr"      ;;
  "dr")cmd_func="scp_dnr"      ;;
  "k") cmd_func="knife_e"      ;;
  *)   echo "nope"; exit 1     ;;
  esac

  eval "${cmd_func} \"\${search_base}\$@\""
}
main "$@"
